{"version":3,"sources":["moment-thai-solar.js"],"names":["global","factory","module","exports","require","define","amd","moment","window","this","extend","a","b","key","hasOwnProperty","objectCreate","parent","F","prototype","getParseRegexForToken","token","config","parseTokenThreeDigits","parseTokenFourDigits","parseTokenSixDigits","parseTokenOneToThreeDigits","parseTokenWord","localeData","lang","_meridiemParse","parseTokenTimestampMs","parseTokenTimezone","parseTokenT","parseTokenOneOrTwoDigits","RegExp","replace","makeDateFromStringAndFormat","tokens","format","match","formattingTokens","string","input","_a","forEach","parsedInput","exec","slice","indexOf","length","formatTokenFunctions","_thaiYear","_isValid","addTimeToArrayFromToken","_thai_leftLength","thai","gYear","month","day","year","tYear","utils","calYear","gy","isLeapYear","localFormattingTokens","formatFunctions","xkY","thaiYear","xky","makeMoment","strict","utc","undefined","origInput","origFormat","Array","isArray","Date","NaN","moments","map","currentScore","tempMoment","isValid","score","sort","m1","m2","makeDateFromStringAndArray","parsed","Function","orgMoment","newMoment","thaiMoment","fn","unix","i","array","me","longDateFormat","test","element","index","mom","output","call","m","date","d","toThai","lastDay","Math","min","thaiDaysInMonth","gregorian","toGregorian","_d","_isUTC","UTC","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","getHours","getMinutes","getSeconds","getMilliseconds","updateOffset","clone","div","mod","thaiIsLeapYear","thaiConvert","gm","gd","jy","jm","jd"],"mappings":"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","file":"moment-thai-solar.min.js","sourcesContent":["/*!\n * moment-thai-solar\n * https://github.com/yociduo/moment-thai-solar#readme\n * Version: 0.0.3 - 2021-01-06T09:32:41.426Z\n * License: MIT\n */\n\n\n(function (global, factory) {\r\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        // CMD\r\n        module.exports = factory(require('moment'));\r\n    } else if (typeof define === 'function' && define.amd) {\r\n        // AMD. Register as parrot\r\n        // TODO how to define the jquery plugin here?\r\n        define(['moment'], factory);\r\n    } else {\r\n        // in browser, assump moment is loaded\r\n        global.moment = factory(moment);\r\n    }\r\n}(typeof window !== \"undefined\" ? window : this, function (moment) {\r\n    // utils\r\n    var thai = {\r\n        /*\r\n         Converts a Gregorian date to Thai.\r\n         */\r\n        toThai: function (gYear, month, day) {\r\n            return {\r\n                year: gYear + 543,\r\n                month: month,\r\n                day: day\r\n            };\r\n        },\r\n        /*\r\n         Converts a Thai date to Gregorian.\r\n         */\r\n        toGregorian: function (tYear, month, day) {\r\n            return {\r\n                year: utils.calYear(tYear),\r\n                month: month,\r\n                day: day\r\n            };\r\n        },\r\n        /**\r\n         * Checks whether a Thai date is valid or not.\r\n         */\r\n        isValidDate: function (tYear, month, day) {\r\n            return month >= 1 && month <= 12 &&\r\n                day >= 1 && day <= utils.monthLength(tYear, month);\r\n        },\r\n        /**\r\n         * check the Gregorian year is leap or not\r\n         * @param gy\r\n         * @returns {boolean}\r\n         */\r\n        isLeapYear: function isLeapYear(gy) {\r\n            return ((gy % 4 == 0) && (gy % 100 != 0)) || (gy % 400 == 0);\r\n        },\r\n        /**\r\n         * Is this a leap year or not?\r\n         * @returns {boolean}\r\n         */\r\n        isLeapThaiYear: function isLeapThaiYear(tYear) {\r\n            return utils.thaiCal(tYear).leap;\r\n        },\r\n        /**\r\n         * Number of days in a given month in a Thai year.\r\n         * @returns {number} days of month\r\n         */\r\n        monthLength: function (tYear, month) {\r\n            switch (month) {\r\n                case 4:\r\n                case 6:\r\n                case 9:\r\n                case 11:\r\n                    return 30;\r\n                case 2:\r\n                    return utils.isLeapYear(utils.calYear(tYear)) ? 29 : 28;\r\n                default:\r\n                    return 31;\r\n            }\r\n        },\r\n        /**\r\n         *\r\n         * @param tYear thai year\r\n         * @returns {{leap: boolean, gy: number}}\r\n         */\r\n        thaiCal: function thaiCal(tYear) {\r\n            var gy = calYear(tYear);\r\n            return {\r\n                leap: isLeapYear(gy),\r\n                gy: gy\r\n            };\r\n        },\r\n        /**\r\n         * calculate the Thai year to Gregorian year\r\n         * @param tYear\r\n         * @returns {number}\r\n         */\r\n        calYear: function calYear(tYear) {\r\n            return tYear - 543;\r\n        }\r\n    };\r\n\r\n    /************************************\r\n     Constants\r\n     ************************************/\r\n    var formattingTokens = /xkY|xky|YY(YY)?|Q|MM?|MMMM?|DD?|Do|DDDD?|X|x|gg(gg)?|ww?|e|dddd?|GG(GG)?|WW?|E|HH?|hh?|a|A|mm?|ss?|SS?S?S?|ZZ?|./g;\r\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LT|LL?L?L?|l{1,4})/g,\r\n\r\n        parseTokenOneOrTwoDigits = /\\d\\d?/,\r\n        parseTokenOneToThreeDigits = /\\d{1,3}/,\r\n        parseTokenThreeDigits = /\\d{3}/,\r\n        parseTokenFourDigits = /\\d{1,4}/,\r\n        parseTokenSixDigits = /[+\\-]?\\d{1,6}/,\r\n        parseTokenWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i,\r\n        parseTokenTimezone = /Z|[\\+\\-]\\d\\d:?\\d\\d/i,\r\n        parseTokenT = /T/i,\r\n        parseTokenTimestampMs = /[\\+\\-]?\\d+(\\.\\d{1,3})?/,\r\n\r\n        formatFunctions = {},\r\n        formatTokenFunctions = {\r\n            xkY: function () {\r\n                return this.thaiYear() + '';\r\n            },\r\n            xky: function () {\r\n                return this.thaiYear() % 100 + '';\r\n            }\r\n        };\r\n\r\n    /************************************\r\n     Helpers\r\n     ************************************/\r\n    var extend = function (a, b) {\r\n        var key;\r\n        for (key in b) {\r\n            if (b.hasOwnProperty(key)) {\r\n                a[key] = b[key];\r\n            }\r\n        }\r\n        return a;\r\n    };\r\n\r\n    var setDate = function (m, year, month, date) {\r\n        var d = m._d;\r\n        if (m._isUTC) {\r\n            /*eslint-disable new-cap*/\r\n            m._d = new Date(Date.UTC(year, month, date,\r\n                d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()));\r\n            /*eslint-enable new-cap*/\r\n        } else {\r\n            m._d = new Date(year, month, date,\r\n                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\r\n        }\r\n    };\r\n\r\n    var objectCreate = function (parent) {\r\n        function F() {}\r\n\r\n        F.prototype = parent;\r\n        return new F();\r\n    };\r\n\r\n    /************************************\r\n     Formatting\r\n     ************************************/\r\n    var makeFormatFunction = function (format) {\r\n        var array = format.match(formattingTokens);\r\n        var length = array.length;\r\n        var i;\r\n\r\n        array.forEach(function (element, index) {\r\n            if (formatTokenFunctions[element]) {\r\n                array[index] = formatTokenFunctions[element];\r\n            }\r\n        });\r\n\r\n        return function (mom) {\r\n            var output = '';\r\n            for (i = 0; i < length; i += 1) {\r\n                output += array[i] instanceof Function ? '[' + array[i].call(mom, format) + ']' : array[i];\r\n            }\r\n            return output;\r\n        };\r\n    };\r\n\r\n    /************************************\r\n     Parsing\r\n     ************************************/\r\n    /**\r\n     * get parse regex for token\r\n     * @param token\r\n     * @param config\r\n     * @returns {*}\r\n     */\r\n    var getParseRegexForToken = function (token, config) {\r\n        switch (token) {\r\n            case 'DDDD':\r\n                return parseTokenThreeDigits;\r\n            case 'xkY':\r\n            case 'YYYY':\r\n                return parseTokenFourDigits;\r\n            case 'YYYYY':\r\n                return parseTokenSixDigits;\r\n            case 'S':\r\n            case 'SS':\r\n            case 'SSS':\r\n            case 'DDD':\r\n                return parseTokenOneToThreeDigits;\r\n            case 'MMM':\r\n            case 'MMMM':\r\n            case 'dd':\r\n            case 'ddd':\r\n            case 'dddd':\r\n                return parseTokenWord;\r\n            case 'a':\r\n            case 'A':\r\n                return moment.localeData(config.lang)._meridiemParse;\r\n            case 'X':\r\n                return parseTokenTimestampMs;\r\n            case 'Z':\r\n            case 'ZZ':\r\n                return parseTokenTimezone;\r\n            case 'T':\r\n                return parseTokenT;\r\n            case 'MM':\r\n            case 'DD':\r\n            case 'xky':\r\n            case 'YY':\r\n            case 'HH':\r\n            case 'hh':\r\n            case 'mm':\r\n            case 'ss':\r\n            case 'M':\r\n            case 'D':\r\n            case 'd':\r\n            case 'H':\r\n            case 'h':\r\n            case 'm':\r\n            case 's':\r\n                return parseTokenOneOrTwoDigits;\r\n            default:\r\n                return new RegExp(token.replace('\\\\', ''));\r\n        }\r\n    };\r\n\r\n    var addTimeToArrayFromToken = function (token, input, config) {\r\n        switch (token) {\r\n            case 'xkY':\r\n                config._thaiYear = ~~input;\r\n                break;\r\n            case 'xky':\r\n                config._thaiYear = ~~input + 2500;\r\n                break;\r\n        }\r\n        if (input == null) {\r\n            config._isValid = false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * get thai year from config\r\n     * @param config\r\n     * @returns {*}\r\n     */\r\n    var yearFromConfig = function (config) {\r\n        return config._thaiYear;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param config\r\n     * @returns {[]}\r\n     */\r\n    var makeDateFromStringAndFormat = function (config) {\r\n        var tokens = config.format.match(formattingTokens);\r\n        var string = config.input + '';\r\n\r\n        config._a = [];\r\n\r\n        tokens.forEach(function (token) {\r\n            var parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];\r\n            if (parsedInput) {\r\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\r\n            }\r\n            if (formatTokenFunctions[token]) {\r\n                addTimeToArrayFromToken(token, parsedInput, config);\r\n            }\r\n        });\r\n        if (string) {\r\n            config._thai_leftLength = string;\r\n        }\r\n        return yearFromConfig(config);\r\n    };\r\n\r\n    /**\r\n     * create moment by given configuration with multiple formats.\r\n     * score of moment is left length of formatting. return moment object with minimum score.\r\n     * @param config\r\n     * @param utc\r\n     * @returns {*}\r\n     */\r\n    var makeDateFromStringAndArray = function (config, utc) {\r\n        if (config.format.length === 0) {\r\n            return makeMoment(new Date(NaN));\r\n        }\r\n\r\n        var moments = config.format.map(function (format) {\r\n            var currentScore = 0;\r\n            var tempMoment = makeMoment(config.input, format, config.lang, config.strict, utc);\r\n            if (tempMoment.isValid()) {\r\n                if (tempMoment._thai_leftLength) {\r\n                    currentScore += tempMoment._thai_leftLength.length;\r\n                }\r\n            }\r\n            return {\r\n                score: currentScore,\r\n                moment: tempMoment\r\n            };\r\n        });\r\n        moments.sort(function (m1, m2) {\r\n            return m1.score - m2.score;\r\n        });\r\n        return moments[0].moment;\r\n    };\r\n\r\n    var removeParsedTokens = function (config) {\r\n        var string = config.input + '';\r\n        var input = '';\r\n        var format = '';\r\n        var array = config.format.match(formattingTokens);\r\n\r\n        array.forEach(function (match) {\r\n            var parsed = (getParseRegexForToken(match, config).exec(string) || [])[0];\r\n            if (parsed) {\r\n                string = string.slice(string.indexOf(parsed) + parsed.length);\r\n            }\r\n            if (!(formatTokenFunctions[match] instanceof Function)) {\r\n                format += match;\r\n                if (parsed) {\r\n                    input += parsed;\r\n                }\r\n            }\r\n        });\r\n        config.input = input;\r\n        var orgFormat = config.format;\r\n        config.format = format;\r\n        return orgFormat != format;\r\n    };\r\n\r\n    /************************************\r\n     Top Level Functions\r\n     ************************************/\r\n    var makeMoment = function (input, format, lang, strict, utc) {\r\n        if (typeof lang === 'boolean') {\r\n            utc = strict;\r\n            strict = lang;\r\n            lang = undefined;\r\n        }\r\n        var config = {\r\n            input: input,\r\n            format: format,\r\n            lang: lang,\r\n            strict: strict,\r\n            utc: utc\r\n        };\r\n        var origInput = input;\r\n        var origFormat = format;\r\n\r\n\r\n        if (format) {\r\n            if (Array.isArray(format)) {\r\n                // create moment by given multiple formats\r\n                return makeDateFromStringAndArray(config, utc);\r\n            } else {\r\n                // create moment by given single format\r\n                var year = makeDateFromStringAndFormat(config);\r\n                var removed = removeParsedTokens(config);\r\n                if (removed) {\r\n                    format = 'YYYY-' + config.format;\r\n                    // has thai format\r\n                    if (typeof year === 'undefined') {\r\n                        // no year parsed, let it be invalid\r\n                        input = 'ABCD-' + config.input;\r\n                    } else {\r\n                        input = thai.calYear(year) + '-' + config.input;\r\n                    }\r\n                } else {\r\n                    // keep original\r\n                    format = origFormat;\r\n                    input = origInput;\r\n                }\r\n                // format = 'YYYY-' + config.format;\r\n                // input = thai.calYear(year) + '-' + config.input;\r\n            }\r\n        }\r\n\r\n        var orgMoment;\r\n        if (utc)\r\n            orgMoment = moment.utc(input, format, lang, strict);\r\n        else\r\n            orgMoment = moment(input, format, lang, strict);\r\n        if (config._isValid === false) {\r\n            orgMoment._isValid = false;\r\n        }\r\n        var newMoment = objectCreate(thaiMoment.fn);\r\n        extend(newMoment, orgMoment);\r\n        if (strict && newMoment.isValid()) {\r\n            newMoment._isValid = newMoment.format(origFormat) === origInput;\r\n        }\r\n        return newMoment;\r\n    };\r\n\r\n    var thaiMoment = function (input, format, lang, strict) {\r\n        return makeMoment(input, format, lang, strict, false);\r\n    };\r\n\r\n    extend(thaiMoment, moment);\r\n    thaiMoment.fn = objectCreate(moment.fn);\r\n\r\n    thaiMoment.utc = function (input, format, lang, strict) {\r\n        return makeMoment(input, format, lang, strict, true);\r\n    };\r\n\r\n    thaiMoment.unix = function (input) {\r\n        return makeMoment(input * 1000);\r\n    };\r\n\r\n    /************************************\r\n     thaiMoment Prototype\r\n     ************************************/\r\n\r\n    thaiMoment.fn.format = function (format) {\r\n        var i, replace, me = this;\r\n        if (format) {\r\n            i = 5;\r\n            replace = function (input) {\r\n                return me.localeData().longDateFormat(input) || input;\r\n            };\r\n            while (i > 0 && localFormattingTokens.test(format)) {\r\n                i -= 1;\r\n                format = format.replace(localFormattingTokens, replace);\r\n            }\r\n            if (!formatFunctions[format]) {\r\n                formatFunctions[format] = makeFormatFunction(format);\r\n            }\r\n            format = formatFunctions[format](this);\r\n        }\r\n        return moment.fn.format.call(this, format);\r\n    };\r\n\r\n    thaiMoment.fn.thaiYear = function (input) {\r\n        var lastDay, thai, gregorian;\r\n        if (typeof input === 'number') {\r\n            thai = toThai(this.year(), this.month(), this.date());\r\n            lastDay = Math.min(thai.year, thaiMoment.thaiDaysInMonth(input, thai.month));\r\n            gregorian = toGregorian(input, thai.month, lastDay);\r\n            setDate(this, gregorian.year, gregorian.month, gregorian.day);\r\n            moment.updateOffset(this);\r\n            return this;\r\n        } else {\r\n            return toThai(this.year(), this.month(), this.date()).year;\r\n        }\r\n    };\r\n\r\n    thaiMoment.fn.clone = function () {\r\n        return thaiMoment(this);\r\n    };\r\n\r\n    /************************************\r\n     thaiMoment Statics\r\n     ************************************/\r\n    thaiMoment.thaiDaysInMonth = function (year, month) {\r\n        year += div(month, 12);\r\n        month = mod(month, 12);\r\n        if (month < 0) {\r\n            month += 12;\r\n            year -= 1;\r\n        }\r\n        return thai.monthLength(year, month);\r\n    };\r\n\r\n    thaiMoment.thaiIsLeapYear = thai.isLeapYear;\r\n\r\n    thaiMoment.thaiConvert = {\r\n        toThai: toThai,\r\n        toGregorian: toGregorian\r\n    };\r\n\r\n    /************************************\r\n     Thai Conversion\r\n     ************************************/\r\n    var toThai = function (gy, gm, gd) {\r\n        var date = thai.toThai(gy, gm + 1, gd);\r\n        date.month -= 1;\r\n        return date;\r\n    };\r\n\r\n    var toGregorian = function (jy, jm, jd) {\r\n        var date = thai.toGregorian(jy, jm + 1, jd);\r\n        date.month -= 1;\r\n        return date;\r\n    };\r\n\r\n    /*\r\n     Utility helper functions.\r\n     */\r\n\r\n    var div = function (a, b) {\r\n        return ~~(a / b);\r\n    };\r\n\r\n    var mod = function (a, b) {\r\n        return a - ~~(a / b) * b;\r\n    };\r\n\r\n    return thaiMoment;\r\n}));"]}